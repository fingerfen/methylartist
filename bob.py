def locus(args):
    '''
    plot methylation profile of a region in CpG space
    '''
    # set up

    assert ':' in args.interval
    assert '-' in args.interval

    if args.panelratios:
        if args.plot_coverage:
            if len(args.panelratios.split(',')) != 6:
                logger.warning('locus -p/--panelratios requires 6 terms e.g. --panelratios 1,5,1,3,3,3')
                sys.exit(1)
        else:
            if len(args.panelratios.split(',')) != 5:
                logger.warning('locus -p/--panelratios requires 5 terms e.g. --panelratios 1,5,1,3,3')
                sys.exit(1)

    if args.motif is not None:
        assert iupac(args.motif)

    chrom, pos = args.interval.split(':')
    elt_start, elt_end = pos.split('-')

    elt_start = int(elt_start.replace(',', ''))
    elt_end = int(elt_end.replace(',', ''))

    data = dd(list)
    user_colours = {}

    markers = ['.', ',', 'o', 'v', '^', '<', '>', '8', 's', 'p', 'P', '*', 'h', 'H', 'X', 'D', 'd']

    if args.readmarker not in markers:
        sys.exit('%s is not a valid marker type, valid types: %s' % (args.readmarker, ','.join(markers)))

    if args.data is None and args.bams is None:
        sys.exit('please specify either -d/--data or -b/--bams')

    methbam = False

    if args.data is not None:
        if args.bams is not None:
            sys.exit('please specify either -d/--data or -b/--bams but not both')

        with open(args.data) as _:
            for line in _:
                c = line.strip().split()
                if len(c) < 2:
                    logger.warning(
                        "required fields for -d/--data are: .bam file and methylation .db (generated by methylartist)")
                    sys.exit()

                bam, meth_db = c[:2]
                for m_db in meth_db.split(','):
                    data[bam].append(m_db)

                if len(c) == 3:
                    user_colours[bam] = c[2]

    if args.motif is not None:
        if len(args.motif) != int(args.motifsize):
            logger.warning(
                'motif size (set with --motifsize) %d does not match length of --motif (%s), changed --motifsize' % (
                int(args.motifsize), args.motif))
            args.motifsize = len(args.motif)

    if args.bams is not None:
        logger.info('mod motif size (--motifsize) = %d (ensure this is correct for your data)' % int(args.motifsize))

        if None in (args.ref, args.motif):
            logger.warning('--ref and --motif are required when using --bams')
            sys.exit(1)

        methbam = True
        bams = []

        if args.bams.endswith('.bam') or (':' in args.bams and args.bams.split(':')[0].endswith('.bam')):
            bams = args.bams.split(',')

        elif is_bam(args.bams):
            bams = args.bams.split(',')

        else:
            logger.info('assuming %s contains a list of .bams' % args.bams)
            with open(args.bams) as bam_list:
                for line in bam_list:
                    c = line.strip().split()
                    if len(c) == 1:
                        bams.append(c[0])
                    elif len(c) == 2:
                        bams.append(c[0])
                        user_colours[bams[-1]] = c[1]
                    else:
                        sys.exit(f'unparsable line in {args.bams}: {line.strip()}')

        for bam in bams:
            if ':' in bam:
                bam, ucol = bam.split(':')
                user_colours[bam] = ucol

            if not os.path.exists(bam):
                sys.exit(f'.bam file not found: {bam}')

            with pysam.AlignmentFile(bam) as fh:
                if not fh.check_index():
                    sys.exit('bam not indexed: %s' % bam)

            data[bam] = None

    # table for plotting

    meth_table = dd(dict)

    sample_order = []

    reads = {}
    orig_bam = {}

    use_mods = None
    if args.mods:
        use_mods = args.mods.split(',')

    phases = {}

    if args.phased:
        for bam in data:
            phased_reads = get_phased_reads(bam, chrom, elt_start, elt_end, tag_untagged=args.include_unphased,
                                            min_mapq=int(args.min_mapq), HP_only=args.ignore_ps)
            phases[bam] = list(set([p for p in phased_reads.values() if p]))
            logger.info('phases for bam %s: %s' % (bam, ','.join(phases[bam])))

    for bam, meth_dbs in data.items():
        if meth_dbs is None:
            mods = mods_methbam(bam)
            logger.info('found mods: %s in bam %s' % (','.join(mods), bam))

        else:
            for meth_db in meth_dbs:
                mods = sorted(get_modnames(meth_db))
                logger.info('found mods: %s in db %s' % (','.join(mods), meth_db))

        for mod in mods:
            if use_mods:
                if mod not in use_mods:
                    logger.info('skipping %s, not specified in -m/--mods %s' % (mod, args.mods))
                    continue
            else:
                use_mods = mods

            if args.phased:
                for phase in phases[bam]:
                    bamname = '.'.join(os.path.basename(bam).split('.')[:-1]) + '.' + phase + '.' + mod
                    orig_bam[bamname] = bam
                    reads[bamname] = get_meth_locus(args, bam, meth_dbs, mod, phase=phase, methbam=methbam,
                                                    HP_only=args.ignore_ps, restrict_motif=args.motif,
                                                    restrict_ref=args.ref)

                    for name, read in reads[bamname].items():
                        for loc in read.llrs.keys():
                            uuid = str(uuid4())
                            meth_table[uuid]['loc'] = loc
                            meth_table[uuid]['modstat'] = read.llrs[loc]
                            meth_table[uuid]['read'] = name
                            meth_table[uuid]['sample'] = bamname
                            meth_table[uuid]['call'] = read.meth_calls[loc]

                            if bamname not in sample_order:
                                sample_order.append(bamname)

            else:
                bamname = '.'.join(os.path.basename(bam).split('.')[:-1]) + '.' + mod
                orig_bam[bamname] = bam
                reads[bamname] = get_meth_locus(args, bam, meth_dbs, mod, methbam=methbam, restrict_motif=args.motif,
                                                restrict_ref=args.ref)

                for name, read in reads[bamname].items():
                    for loc in read.llrs.keys():
                        uuid = str(uuid4())
                        meth_table[uuid]['loc'] = loc
                        meth_table[uuid]['modstat'] = read.llrs[loc]
                        meth_table[uuid]['read'] = name
                        meth_table[uuid]['sample'] = bamname
                        meth_table[uuid]['call'] = read.meth_calls[loc]

                        if bamname not in sample_order:
                            sample_order.append(bamname)

    meth_table = pd.DataFrame.from_dict(meth_table).T

    if 'loc' not in meth_table:
        sys.exit('%s: insufficient coverage for plot' % args.interval)

    meth_table['loc'] = pd.to_numeric(meth_table['loc'])
    meth_table['modstat'] = pd.to_numeric(meth_table['modstat'])

    meth_table['orig_loc'] = meth_table['loc']
    meth_table['loc'] = ss.rankdata(meth_table['loc'], method='dense')

    if len(meth_table['orig_loc']) == 0:
        sys.exit('%s: insufficient coverage for plot' % args.interval)

        # optional mincall filter

    if int(args.mincalls) > 0:
        drop_ix = []

        logger.info('assessing coverage per --mincalls, per-read sites to consider: %d' % len(meth_table['loc']))
        tick = 5000
        for i, new_loc in enumerate(meth_table['loc'], 1):
            for sample in sample_order:
                call_count = len(meth_table.loc[(meth_table['sample'] == sample) & (meth_table['loc'] == new_loc)])

                if call_count < int(args.mincalls):
                    drop_ix += list(meth_table.loc[(meth_table['loc'] == new_loc)].index)

            if i % tick == 0:
                logger.info('%s %s: processed %d sites' % (args.data, args.interval, i))

        drop_ix = list(set(drop_ix))
        logger.info('dropping %d positions' % len(drop_ix))
        meth_table.drop(drop_ix, inplace=True)

        meth_table['loc'] = ss.rankdata(meth_table['loc'], method='dense')

        if len(meth_table['orig_loc']) == 0:
            sys.exit('%s: insufficient coverage for plot' % args.interval)

    # create mod space

    coord_to_cpg = {}
    for orig_loc, new_loc in zip(meth_table['orig_loc'], meth_table['loc']):
        coord_to_cpg[orig_loc] = new_loc

    # calibrate plotting parameters
    logger.info('region size: %d' % (elt_end - elt_start))

    modspace_n = len(list(set(coord_to_cpg.values())))
    logger.info('mod space positions: %d' % modspace_n)

    if args.modspace is not None:
        logger.info(
            'user set --modspace %d, mod_n:ticks: %.3f' % (int(args.modspace), modspace_n / float(args.modspace)))
        args.modspace = int(args.modspace)
    else:
        if modspace_n <= 1200:
            args.modspace = 1
        else:
            args.modspace = round(modspace_n / 1200)

        logger.info('auto set --modspace %d' % args.modspace)

    if args.smoothwindowsize is not None:
        logger.info('user set --smoothwindowsize %d, mod_n:smoothwindowsize: %.3f' % (
        int(args.smoothwindowsize), modspace_n / float(args.smoothwindowsize)))
        args.smoothwindowsize = int(args.smoothwindowsize)

        if args.smoothwindowsize % 2 != 0:
            args.smoothwindowsize += 1
            logger.info('-s/--smoothwindowsize must be an even integer, adjusted value: %d' % args.smoothwindowsize)

    else:
        args.smoothwindowsize = round(0.0167 * modspace_n + 18)

        if args.smoothwindowsize % 2 != 0:
            args.smoothwindowsize += 1

        logger.info('auto set --smoothwindowsize %d' % args.smoothwindowsize)

    # data for coverage plot

    cover_bams = {}

    if args.plot_coverage:
        cov_bams = []

        if args.plot_coverage.endswith('.bam'):
            cov_bams = args.plot_coverage.split(',')

        if args.plot_coverage.endswith('.txt'):
            with open(args.plot_coverage) as _:
                for fn in _:
                    cov_bams.append(fn.strip())

        for bam_fn in cov_bams:
            logger.info('gather coverage from %s...' % bam_fn)

            meth_seg_starts = deepcopy(np.asarray(meth_table['orig_loc']))
            meth_seg_starts += elt_start

            cover = bam_pileupcover(bam_fn, chrom, meth_seg_starts, meth_seg_starts, procs=int(args.coverprocs),
                                    log=args.logcover)

            c_name = '.'.join(os.path.basename(bam_fn).split('.')[:-1])

            cover_table = dd(dict)
            sorted_locs = sorted(list(set(meth_table['loc'])))

            for c, loc in zip(cover, sorted_locs):
                uuid = str(uuid4())
                cover_table[uuid]['loc'] = loc
                cover_table[uuid]['sample'] = c_name
                cover_table[uuid]['cover'] = c

            cover_table = pd.DataFrame.from_dict(cover_table).T

            windowed_cover = slide_window_cover(cover_table, c_name, width=int(args.slidingwindowsize),
                                                slide=int(args.slidingwindowstep))
            cover_bams[c_name] = smooth(np.asarray(list(windowed_cover.values())),
                                        window_len=int(args.smoothwindowsize), window=args.smoothfunc)

    # highlights

    h_start = []
    h_end = []
    h_cpg_start = []
    h_cpg_end = []
    h_colors = []

    if args.highlight:
        h_colors = sns.color_palette(args.highlightpalette, n_colors=len(args.highlight.split(',')))

    if args.highlight:
        for h in args.highlight.split(','):
            if ':' in h:
                h = h.split(':')[-1]

            h_s, h_e = map(int, h.split('-'))
            h_start.append(h_s - elt_start)
            h_end.append(h_e - elt_start)

            h_cpg_start.append(coord_to_cpg[min(meth_table['orig_loc'], key=lambda x: abs(x - h_start[-1]))])
            h_cpg_end.append(coord_to_cpg[min(meth_table['orig_loc'], key=lambda x: abs(x - h_end[-1]))])

    if args.highlight_bed:
        need_colour = 0

        with open(args.highlight_bed) as h_bed:
            for line in h_bed:
                c = line.strip().split()
                assert len(c) >= 3, 'malformed line in --highlight_bed: %s' % line.strip()

                if c[0] != chrom:
                    continue

                h_s, h_e = map(int, c[1:3])

                assert h_s < h_e

                if h_s < elt_start:
                    continue

                if h_e > elt_end:
                    continue

                colour = None

                if len(c) > 3:
                    colour = c[3]
                else:
                    need_colour += 1

                h_start.append(h_s - elt_start)
                h_end.append(h_e - elt_start)

                h_cpg_start.append(coord_to_cpg[min(meth_table['orig_loc'], key=lambda x: abs(x - h_start[-1]))])
                h_cpg_end.append(coord_to_cpg[min(meth_table['orig_loc'], key=lambda x: abs(x - h_end[-1]))])

                h_colors.append(colour)

            logger.info('found %d within-interval highlight regions in %s' % (len(h_start), args.highlight_bed))

        more_colours = sns.color_palette(args.highlightpalette, n_colors=need_colour)

        for i, c in enumerate(h_colors):
            if c is None:
                h_colors[i] = more_colours.pop()

    # mask

    readmask = []
    if args.readmask:
        for ivl in args.readmask.split(','):
            if ':' in ivl:
                ivl = ivl.split(':')[1]
            assert '-' in ivl, 'malformed --readmask interval(s): %s' % args.readmask

            readmask.append(list(map(int, ivl.split('-'))))

    # set up plot
    p_ratios = [1, 5, 1, 3, 3]
    if args.plot_coverage:
        p_ratios.append(3)

    fig = plt.figure(figsize=(10, 30))
    gs = gridspec.GridSpec(len(p_ratios), 1, height_ratios=p_ratios, hspace=0)

    img_w = 16
    img_h = 8

    if args.width:
        img_w = float(args.width)

    if args.height:
        img_h = float(args.height)

    fig.set_size_inches(img_w, img_h)

    if args.panelratios:
        p_ratios = list(map(int, args.panelratios.split(',')))
        if args.plot_coverage and len(p_ratios) < 5:
            logger.warning('--panelratios must have 5 values if used with --plot_coverage')
            sys.exit(1)

        gs = gridspec.GridSpec(len(p_ratios), 1, height_ratios=p_ratios, hspace=0)

    sample_color = {}
    for i, sample in enumerate(sample_order):
        sample_color[sample] = sns.color_palette(args.samplepalette, n_colors=len(sample_order))[i]

    if args.color_by_phase:
        if args.phased:
            basenames = ['.'.join(sample.split('.')[:-2]) for sample in sample_color]

            base_colors = {}

            for i, basename in enumerate(basenames):
                base_colors[basename] = sns.color_palette(args.samplepalette, n_colors=len(basenames))[i]

            for sample in sample_color:
                basename = '.'.join(sample.split('.')[:-2])
                sample_color[sample] = base_colors[basename]

        else:
            logger.warning('--color_by_phase has no effect without --phased')

    for sample in sample_color:
        if orig_bam[sample] in user_colours:
            sample_color[sample] = user_colours[orig_bam[sample]]

    if args.color_by_hp:
        if args.phased:
            hp_color = {}
            for hp in ('1', '2'):
                hp_color[hp] = sns.color_palette(args.samplepalette, n_colors=2)[int(hp) - 1]

            for sample in sample_color:
                hp = sample.split('.')[-2]
                assert hp in ('1', '2')
                sample_color[sample] = hp_color[hp]

        else:
            logger.warning('--color_by_hp has no effect without --phased')

    cover_color = {}

    if args.plot_coverage:
        for i, c_name in enumerate(cover_bams.keys()):
            cover_color[c_name] = sns.color_palette(args.coverpalette, n_colors=len(cover_bams))[i]

    # plot genes

    ax0 = plt.subplot(gs[0])

    ax0.spines['bottom'].set_visible(False)
    ax0.spines['left'].set_visible(False)
    ax0.spines['right'].set_visible(False)
    ax0.xaxis.set_ticks_position('top')

    gtf = None
    genes = []

    if args.gtf is not None:
        logger.info('building genes plot...')
        gtf = pysam.Tabixfile(args.gtf)
        genes = build_genes(gtf, chrom, elt_start, elt_end, tx=args.show_transcripts)

    exon_patches = []
    tx_lines = []

    genes_of_interest = []

    if args.genes is not None:
        genes_of_interest = args.genes.strip().split(',')

    genemap = dd(Intersecter)

    if genes_of_interest:
        new_genes = {}
        for ensg in genes:
            if genes[ensg].name in genes_of_interest:
                new_genes[ensg] = genes[ensg]

        genes = new_genes

    gene_colours = sns.color_palette(args.genepalette, n_colors=len(genes))

    y = 1

    for i, ensg in enumerate(genes):
        if not genes[ensg].has_tx():
            logger.warning('no transcript for gene: %s' % genes[ensg].name)
            continue

        logger.info('gene in region: %s' % genes[ensg].name)

        y = 1

        while genemap[y].find(genes[ensg].tx_start - elt_start, genes[ensg].tx_end - elt_start):
            y += (float(args.exonheight) + 0.7)

        tx_offset = float(args.exonheight) / 2.0

        tx_lines.append(matplotlib.lines.Line2D([genes[ensg].tx_start - elt_start, genes[ensg].tx_end - elt_start],
                                                [tx_offset + y, tx_offset + y], color=gene_colours[i], zorder=2))

        genes[ensg].merge_exons()
        for exon_start, exon_end in genes[ensg].exons:
            exon_len = exon_end - exon_start
            exon_patches.append(
                matplotlib.patches.Rectangle([exon_start - elt_start, y], exon_len, float(args.exonheight),
                                             edgecolor=gene_colours[i], facecolor=gene_colours[i], zorder=3))

        if args.labelgenes:
            label = genes[ensg].name

            if genes[ensg].strand in ('+', '-'):
                if genes[ensg].strand == '+':
                    label += '>>'

                else:
                    label = '<<' + label

            lg_x = max(genes[ensg].tx_start - elt_start, 0)

            nudge_up = 0.0
            if genes[ensg].tx_start - elt_start < 0:
                nudge_up = tx_offset + 0.1

            gtxt = ax0.text(lg_x, y + nudge_up, label, zorder=4, fontsize='small')
            bb_w = gtxt.get_tightbbox(renderer=fig.canvas.get_renderer()).width
            fig_w = fig.get_size_inches()[0] * fig.dpi
            txt_w = bb_w / fig_w * (elt_end - elt_start)
            gtxt.set_x(lg_x - txt_w * 1.42)

            genemap[y].add_interval(Interval(genes[ensg].tx_start - elt_start - (txt_w * 1.5),
                                             genes[ensg].tx_end - elt_start + (txt_w * 1.5)))

        else:
            genemap[y].add_interval(Interval(genes[ensg].tx_start - elt_start, genes[ensg].tx_end - elt_start))

    gene_height = max(4, len(genemap))

    if args.labelgenes:
        gene_height = max(8, len(genemap))

    if args.bed:
        logger.info('loading annotations from %s' % args.bed)
        gene_height += 3

        y += 1

        bed_annotations = get_bed_annotations(args.bed, chrom, elt_start, elt_end)
        bed_colours = sns.color_palette(args.genepalette, n_colors=len(bed_annotations))

        for i, ann in enumerate(bed_annotations):
            bed_colour = bed_colours[i]

            if ann.colour is not None:
                bed_colour = ann.colour

            exon_patches.append(
                matplotlib.patches.Rectangle([ann.start - elt_start, y], (ann.end - ann.start), float(args.exonheight),
                                             edgecolor=bed_colour, facecolor=bed_colour, zorder=3))

            if ann.label is not None:
                lg_x = max(ann.start - elt_start, 0)
                label = ann.label

                if ann.strand is not None:
                    if ann.strand == '+':
                        label += '>>'

                    else:
                        label = '<<' + label

                gtxt = ax0.text(lg_x, y, label, bbox=dict(boxstyle="round,pad=0.3", fc="lavender", alpha=0.5, lw=0),
                                zorder=4)

    ax0.set_ylim(0, gene_height)
    ax0.set_yticks([])

    highlight_patches = []

    if args.highlight_alpha:
        a = float(args.highlight_alpha)
        if args.highlight or args.highlight_bed:
            for h, h_s in enumerate(h_start):
                h_e = h_end[h]
                h_color = h_colors[h]
                ymin = min(ax0.get_ybound())
                yheight = max(ax0.get_ybound()) - ymin
                highlight_patches.append(
                    matplotlib.patches.Rectangle([h_s, ymin], h_e - h_s, yheight, edgecolor=None, facecolor=h_color,
                                                 alpha=a, zorder=1))

    for h in highlight_patches:
        ax0.add_patch(h)

    for p in exon_patches:
        ax0.add_patch(p)

    for tx in tx_lines:
        ax0.add_line(tx)

    # per-read plot

    logger.info('building read alignment plot...')
    ax1 = plt.subplot(gs[1])
    ax1.set_xticks([])
    ax1.set_yticks([])

    readstack = dd(list)

    max_y = 1
    pack_y = 1

    masked_count = 0

    for bamname in reads:
        fetch_reads_bam = pysam.AlignmentFile(orig_bam[bamname])
        pos_cache = {}

        for read in fetch_reads_bam.fetch(chrom, elt_start, elt_end):
            if read.mapq < int(args.min_mapq):
                continue

            if read.is_supplementary or read.is_secondary or read.is_duplicate:
                if not args.allreads:
                    continue

            masked = False
            if len(readmask) > 0:
                for mask_start, mask_end in readmask:
                    if read.reference_start >= mask_start and read.reference_end <= mask_end:
                        logger.debug('masked read: %s' % read.query_name)
                        masked_count += 1
                        masked = True

            if masked:
                continue

            if read.query_name not in pos_cache:
                pos_cache[read.query_name] = ([read.reference_start], [read.reference_end])
            else:
                pos_cache[read.query_name][0].append(read.reference_start)
                pos_cache[read.query_name][1].append(read.reference_end)

        for readname, read in reads[bamname].items():
            if readname not in pos_cache:
                logger.debug('read %s not found in %s (skipped)' % (readname, bamname))
                continue

            if read.call_count == 0:
                continue

            read.ypos = max_y
            max_y += 1

            read.starts, read.ends = pos_cache[readname]
            readstack[bamname].append(read)

        fetch_reads_bam.close()

    if args.readmask:
        logger.info('masked %d reads due to --readmask' % masked_count)

    # read packing

    for bamname in readstack:
        reads = readstack[bamname]

        y = dd(list)

        for read in readstack[bamname]:
            y[read.ypos].append(read)

        for p in y:
            for q in y:
                if p == q:
                    continue

                for read_q in y[q]:
                    move = True

                    for read_p in y[p]:
                        if read_q.overlap(read_p):
                            move = False

                    if move:
                        y[p].append(read_q)
                        y[q].remove(read_q)

        for p in y:
            if len(y[p]) > 0:
                for read in sorted(y[p], key=lambda r: min(r.starts)):
                    read.ypos = pack_y
                pack_y += 1

    ax1.set_ylim(0, pack_y + 1)

    for bamname in readstack:
        for read in readstack[bamname]:
            rm = args.readmarker
            ms = float(args.readmarkersize)
            lw = float(args.readlinewidth)
            la = float(args.readlinealpha)
            ma = float(args.markeralpha)
            uec = sample_color[bamname]

            if args.readopenmarkeredgecolor is not None:
                uec = args.readopenmarkeredgecolor

            for call_pos, call in read.meth_calls.items():
                if call == -1:
                    ax1.plot(call_pos, read.ypos, marker=rm, fillstyle='full', mec=uec, mfc='white', markersize=ms,
                             zorder=3, alpha=ma)

                if call == 1:
                    ax1.plot(call_pos, read.ypos, marker=rm, fillstyle='full', mec='black', mfc='black', markersize=ms,
                             zorder=3, alpha=ma)

            for i in range(len(read.starts)):
                readline_start = max(read.starts[i], elt_start) - elt_start
                readline_end = min(read.ends[i], elt_end) - elt_start

                ax1.add_line(
                    matplotlib.lines.Line2D([readline_start, readline_end], [read.ypos, read.ypos], lw=lw, zorder=2,
                                            color=sample_color[bamname], alpha=la))

    highlight_patches = []

    if args.highlight_alpha:
        a = float(args.highlight_alpha)
        if args.highlight or args.highlight_bed:
            for h, h_s in enumerate(h_start):
                h_e = h_end[h]
                h_color = h_colors[h]
                ymin = min(ax1.get_ybound())
                yheight = max(ax1.get_ybound()) - ymin
                highlight_patches.append(
                    matplotlib.patches.Rectangle([h_s, ymin], h_e - h_s, yheight, edgecolor=None, facecolor=h_color,
                                                 alpha=a, zorder=1))

    for h in highlight_patches:
        ax1.add_patch(h)

    # plot correspondence between genome space and cpg space

    logger.info('building mod-space plot...')
    ax2 = plt.subplot(gs[2])
    ax3 = ax2.twiny()

    ax2.set_ylim(0, 10)
    ax2.set_yticklabels([])

    x1 = []
    x2 = []

    step = int(args.modspace)

    orig_positions = list(set(meth_table['orig_loc']))

    for i, x in enumerate(orig_positions):
        if i in (0, len(orig_positions) - 1):
            x2.append(x)
            x1.append(coord_to_cpg[x])

        elif i % step == 0:
            x2.append(x)
            x1.append(coord_to_cpg[x])

    ax2.vlines(x1, 0, 1, color='#777777', zorder=1)
    ax3.vlines(x2, 9, 10, color='#777777', zorder=1)

    if args.highlight or args.highlight_bed:
        for i in range(len(h_start)):
            orig_highlight_box = matplotlib.patches.Rectangle((h_start[i], 9), h_end[i] - h_start[i], 1.0, lw=1,
                                                              edgecolor='#777777', facecolor=h_colors[i], zorder=2)
            cpg_highlight_box = matplotlib.patches.Rectangle((h_cpg_start[i], 0), h_cpg_end[i] - h_cpg_start[i], 1.0,
                                                             lw=1, edgecolor='#777777', facecolor=h_colors[i], zorder=3)

            ax3.add_patch(orig_highlight_box)
            ax2.add_patch(cpg_highlight_box)

    for x1_x, x2_x in zip(x1, x2):
        link_end1 = (x1_x, 1)
        link_end2 = (x2_x, 9)

        l_col = '#777777'

        for i in range(len(h_start)):
            if x2_x >= h_start[i] and x2_x <= h_end[i]:
                l_col = h_colors[i]

        con = ConnectionPatch(xyA=link_end1, xyB=link_end2, coordsA="data", coordsB="data", axesA=ax2, axesB=ax3,
                              color=l_col)
        ax3.add_artist(con)

    ax0.set_xlim(ax3.get_xlim())  # sync axes between orig coords and gtf plot
    ax1.set_xlim(ax3.get_xlim())
    ax2.set_xticks([])
    ax3.set_xticks([])

    n_ticks = int(args.nticks) + 1
    tick_interval = (elt_end - elt_start) / n_ticks
    tick_list = list(range(int(ax0.get_xlim()[0]), int(ax0.get_xlim()[1]), int(tick_interval)))

    revised_tick_list = []
    for t in tick_list:
        if t < 0:
            revised_tick_list.append(0)
        else:
            revised_tick_list.append(t)

    tick_list = sorted(list(set(revised_tick_list)))

    xt_labels = [str(int(t + elt_start)) for t in tick_list]
    xt_labels[0] = chrom

    ax0.set_xticks(tick_list)

    if n_ticks > 11:
        ax0.set_xticklabels(xt_labels, rotation=45)
    else:
        ax0.set_xticklabels(xt_labels)

    # llr plot

    logger.info('building llr plot...')
    ax4 = plt.subplot(gs[3])
    ax4.set_xticks([])
    ax4.yaxis.tick_right()

    ax4.axhline(y=0, c='#bbbbbb', linestyle='--', lw=1)

    for mod in use_mods:
        upper = 1.0
        lower = 0.0

        if not methbam:
            upper, lower = get_cutoffs(list(data.values())[0][0], mod)

        ax4.axhline(y=upper, c='k', linestyle='--', lw=1)
        ax4.axhline(y=lower, c='k', linestyle='--', lw=1)

    ax4 = sns.lineplot(x='loc', y='modstat', hue='sample', data=meth_table, palette=sample_color, zorder=2)

    if args.statname:
        ax4.set_ylabel(args.statname)

    ax4.set_xlim(ax2.get_xlim())

    highlight_patches = []

    if args.highlight_alpha:
        a = float(args.highlight_alpha)
        if args.highlight or args.highlight_bed:
            for h, h_s in enumerate(h_cpg_start):
                h_e = h_cpg_end[h]
                h_color = h_colors[h]
                ymin = min(ax4.get_ybound())
                yheight = max(ax4.get_ybound()) - ymin
                highlight_patches.append(
                    matplotlib.patches.Rectangle([h_s, ymin], h_e - h_s, yheight, edgecolor=None, facecolor=h_color,
                                                 alpha=a, zorder=1))

    for h in highlight_patches:
        ax4.add_patch(h)

    # meth frac plot

    logger.info('building meth frac plot...')
    ax5 = plt.subplot(gs[4])

    order_stack = 2

    smoothalpha = float(args.smoothalpha)

    if smoothalpha > 1.0 or smoothalpha < 0.0:
        logger.warning('--smoothalpha must be between 0 and 1, set to 1.0')
        smoothalpha = 1.0

    smoothed_values = dd(dict)

    for sample in sample_order:
        windowed_methfrac, meth_n = slide_window(meth_table, sample, width=int(args.slidingwindowsize),
                                                 slide=int(args.slidingwindowstep))

        smoothed_methfrac = smooth(np.asarray(list(windowed_methfrac.values())), window_len=int(args.smoothwindowsize),
                                   window=args.smoothfunc)

        ix = np.asarray(list(windowed_methfrac.keys()))

        for i, smooth_val in enumerate(smoothed_methfrac):
            smoothed_values[sample][ix[i]] = smooth_val

        masked_segs = mask_methfrac(list(meth_n.values()), cutoff=args.maskcutoff)

        frac_masked = len(list(itertools.chain(*masked_segs))) / len(meth_n.values())

        logger.info('%s:%d-%d (%s), sample %s fraction masked: %.3f' % (
        chrom, elt_start, elt_end, ''.join(use_mods), sample, frac_masked))

        if frac_masked > float(args.maxmaskedfrac):
            logger.warning('%s:%d-%d (%s), skip sample %s due to --maxmaskedfrac %.3f' % (
            chrom, elt_start, elt_end, ''.join(use_mods), sample, float(args.maxmaskedfrac)))
            continue

        if frac_masked > 0.1 and args.bams is not None and args.ref is None:
            logger.warning(
                '*** WARNING: specifying a reference genome (indexed via samtools faidx) with --restrict_ref is strongly recommended when using mod .bams ***')

        ax5.plot(list(windowed_methfrac.keys()), smoothed_methfrac, marker='', lw=4, color=sample_color[sample],
                 alpha=smoothalpha)

        order_stack += 1

        if not args.nomask:
            for seg in masked_segs:
                if len(seg) > 2:
                    mf_seg = np.asarray(smoothed_methfrac)[seg]
                    pos_seg = np.asarray(list(windowed_methfrac.keys()))[seg]

                    ax5.plot(pos_seg, mf_seg, marker='', lw=4, color='#ffffff', alpha=0.8, zorder=order_stack)

                    order_stack += 1

    if args.smoothed_csv:
        smoothed_df = pd.DataFrame(smoothed_values).T
        smoothed_df.to_csv(args.smoothed_csv)

    ax4.set_zorder(order_stack)  # adjust z-level of legend after smoothed plot is finished

    if args.color_by_hp:
        handles, labels = ax4.get_legend_handles_labels()
        phases = list(set([label.split('.')[-2] for label in labels]))

        found_phases = {}

        new_labels = []
        new_handles = []

        if args.phase_labels:
            if ':' not in args.phase_labels:
                sys.exit('incorrect syntax: %s' % args.phase_labels)

            phase_labels = dict([pl.split(':') for pl in args.phase_labels.split(',')])

        for i, label in enumerate(labels):
            hp = label.split('.')[-2]
            if hp not in found_phases:
                phase_name = hp

                if args.phase_labels:
                    if hp in phase_labels:
                        phase_name = phase_labels[hp]

                new_labels.append(phase_name)
                new_handles.append(handles[i])

            found_phases[hp] = True

        ax4.legend(new_handles, new_labels)

    ax5.set_xlim(ax2.get_xlim())
    ax5.set_ylim((float(args.ymin), float(args.ymax)))

    highlight_patches = []

    if args.highlight_alpha:
        a = float(args.highlight_alpha)
        if args.highlight or args.highlight_bed:
            for h, h_s in enumerate(h_cpg_start):
                h_e = h_cpg_end[h]
                h_color = h_colors[h]
                ymin = min(ax5.get_ybound())
                yheight = max(ax5.get_ybound()) - ymin
                highlight_patches.append(
                    matplotlib.patches.Rectangle([h_s, ymin], h_e - h_s, yheight, edgecolor=None, facecolor=h_color,
                                                 alpha=a, zorder=1))

    for h in highlight_patches:
        ax5.add_patch(h)

    # coverage plot (optional)

    if args.plot_coverage:
        logger.info('building coverage plot...')
        ax6 = plt.subplot(gs[5])

        for sample in cover_bams:
            offset = list(windowed_methfrac.keys())[0]
            matched_cover = [cover_bams[sample][i - offset] for i in windowed_methfrac.keys()]

            ax6.plot(list(windowed_methfrac.keys()), matched_cover, marker='', lw=4, color=cover_color[sample],
                     zorder=3, label=sample, alpha=smoothalpha)

        ax6.legend()
        ax6.set_xlim(ax2.get_xlim())

        highlight_patches = []

        if args.highlight_alpha:
            a = float(args.highlight_alpha)
            if args.highlight or args.highlight_bed:
                for h, h_s in enumerate(h_cpg_start):
                    h_e = h_cpg_end[h]
                    h_color = h_colors[h]
                    ymin = min(ax6.get_ybound())
                    yheight = max(ax6.get_ybound()) - ymin
                    highlight_patches.append(
                        matplotlib.patches.Rectangle([h_s, ymin], h_e - h_s, yheight, edgecolor=None, facecolor=h_color,
                                                     alpha=a, zorder=1))

        for h in highlight_patches:
            ax6.add_patch(h)

    fn_prefix = '.%s_%d_%d.%s' % (chrom, elt_start, elt_end, ''.join(use_mods))

    if methbam:
        fn_prefix = '.'.join(os.path.basename(args.bams.split(',')[0]).split('.')[:-1]) + fn_prefix
        if len(args.bams.split(',')) > 1:
            fn_prefix += '.cohort'
    else:
        fn_prefix = '.'.join(os.path.basename(args.data).split('.')[:-1]) + fn_prefix

    if args.genes is not None:
        fn_prefix = '_'.join(args.genes.split(',')) + '.' + fn_prefix

    if args.phased:
        if args.phasediff:
            fn_prefix += '.phasediff'
        else:
            fn_prefix += '.phased'

    param_str = '.ms%d.smw%d' % (args.modspace, int(args.smoothwindowsize))

    fn_prefix += param_str

    if args.max_read_density:
        fn_prefix += '.mrd%.2f' % float(args.max_read_density)

    if int(args.mincalls) > 0:
        fn_prefix += '.mc%d' % int(args.mincalls)

    outfn = fn_prefix

    if args.svg:
        outfn += '.locus.meth.svg'
    else:
        outfn += '.locus.meth.png'

    if args.outfile is not None:
        outfn = args.outfile
        if args.svg:
            if outfn.split('.')[-1] != 'svg':
                logger.warning('warning: %s does not have extension .svg, appending')
                outfn += '.svg'

    fig.savefig(outfn, bbox_inches='tight')
    logger.info('plot saved to %s' % outfn)